{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Pytcher Pytcher is a REST micro-framework for Python that relies on a routing tree similar to RODA in Ruby, Akka HTTP in Scala or Javalin in Java. Features Marshalling / Unmarshalling of data classes (using types), namedtuples , date , datetime , uuid , ... Routing tree definition Routing decorator similar to Flask Well scoped objects (no global variables) Support for WSGI Simple example from pytcher import App , Router , Request , Integer class MyRouter ( object ): def __init__ ( self ): self . version = 'v1' self . _items = [ 'pizza' , 'cheese' , 'ice-cream' , 'butter' ] @route def route ( self , r : Request ): with r / self . version / 'items' : with r . end : with r . get : return self . _items with r . post : self . _items . append ( r . json ) return self . _items [ - 1 ] with r / Integer () as [ item_id ]: with r . get : return self . _items [ item_id ] with r . put : self . _items [ item_id ] = r . json return self . _items [ item_id ] with r . delete : return self . _items . pop ( item_id ) if __name__ == '__main__' : app = App ( MyRouter ()) app . start ()","title":"Home"},{"location":"#welcome-to-pytcher","text":"Pytcher is a REST micro-framework for Python that relies on a routing tree similar to RODA in Ruby, Akka HTTP in Scala or Javalin in Java.","title":"Welcome to Pytcher"},{"location":"#features","text":"Marshalling / Unmarshalling of data classes (using types), namedtuples , date , datetime , uuid , ... Routing tree definition Routing decorator similar to Flask Well scoped objects (no global variables) Support for WSGI","title":"Features"},{"location":"#simple-example","text":"from pytcher import App , Router , Request , Integer class MyRouter ( object ): def __init__ ( self ): self . version = 'v1' self . _items = [ 'pizza' , 'cheese' , 'ice-cream' , 'butter' ] @route def route ( self , r : Request ): with r / self . version / 'items' : with r . end : with r . get : return self . _items with r . post : self . _items . append ( r . json ) return self . _items [ - 1 ] with r / Integer () as [ item_id ]: with r . get : return self . _items [ item_id ] with r . put : self . _items [ item_id ] = r . json return self . _items [ item_id ] with r . delete : return self . _items . pop ( item_id ) if __name__ == '__main__' : app = App ( MyRouter ()) app . start ()","title":"Simple example"},{"location":"user/example/","text":"","title":"Examples"},{"location":"user/exception/","text":"Default exception handlers Exceptions can be intercepted and converted to a response with a status code. By default, if debug is enabled (by default), the exception will be captured and the server will response with error 500 with a detailed error description containing the error, the url, the headers and the stack trace: { \"error\" : \"list index out of range\" , \"url\" : \"/items/444\" , \"headers\" : { \"wsgi.input\" : \"<_io.BufferedReader name=7>\" , \"wsgi.errors\" : \"<_io.TextIOWrapper name='<stderr>' mode='w' encoding='UTF-8'>\" , \"wsgi.version\" : \"(1, 0)\" , \"wsgi.run_once\" : \"False\" , \"wsgi.multithread\" : \"True\" , \"wsgi.multiprocess\" : \"False\" , \"wsgi.file_wrapper\" : \"<class 'wsgiref.util.FileWrapper'>\" }, \"stack_trace\" : [ \"Traceback (most recent call last):\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 124, in _handle_request\" , \" None\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 117, in <genexpr>\" , \" output\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 120, in <genexpr>\" , \" for router in self._routers\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/__init__.py\\\", line 151, in run_router\" , \" return router.func(request, *matched_vars)\" , \" File \\\"examples/simple_app.py\\\", line 22, in route\" , \" return self._items[item_id]\" , \"IndexError: list index out of range\" , \"\" ] } If debug is disabled (for example in production), a simple Internal error message will be returned: { \"error\" : \"Internal Error\" } Customize exception handlers If one wants to intercept other exceptions and not use the default ones, one can create a function or a method inside a class and use the decorator handle_exception with the exception to capture. The following example captures the ValueError exceptions and return a response with the exception message. from pytcher import Request , handle_exception @handle_exception ( ValueError ) def handle_value_error ( request : Request , exception : ValueError ): return { \"error\" : str ( exception ) } And then pass it to the application App : from pytcher import App app = App ([ router , handle_value_error ]) app . run () Note that it can also be defined in the same class that defines the route: from pytcher import App , Request , route , handle_exception class MyRoute ( object ): @route ( path = '/items' ) def route ( self , r : Request ): return \"Hello\" @handle_exception ( ValueError ) def handle_value_error ( self , request : Request , exception : ValueError ): return { \"error\" : str ( exception ) } app = App ( MyRoute ()) app . run ()","title":"Exception"},{"location":"user/exception/#default-exception-handlers","text":"Exceptions can be intercepted and converted to a response with a status code. By default, if debug is enabled (by default), the exception will be captured and the server will response with error 500 with a detailed error description containing the error, the url, the headers and the stack trace: { \"error\" : \"list index out of range\" , \"url\" : \"/items/444\" , \"headers\" : { \"wsgi.input\" : \"<_io.BufferedReader name=7>\" , \"wsgi.errors\" : \"<_io.TextIOWrapper name='<stderr>' mode='w' encoding='UTF-8'>\" , \"wsgi.version\" : \"(1, 0)\" , \"wsgi.run_once\" : \"False\" , \"wsgi.multithread\" : \"True\" , \"wsgi.multiprocess\" : \"False\" , \"wsgi.file_wrapper\" : \"<class 'wsgiref.util.FileWrapper'>\" }, \"stack_trace\" : [ \"Traceback (most recent call last):\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 124, in _handle_request\" , \" None\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 117, in <genexpr>\" , \" output\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 120, in <genexpr>\" , \" for router in self._routers\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/__init__.py\\\", line 151, in run_router\" , \" return router.func(request, *matched_vars)\" , \" File \\\"examples/simple_app.py\\\", line 22, in route\" , \" return self._items[item_id]\" , \"IndexError: list index out of range\" , \"\" ] } If debug is disabled (for example in production), a simple Internal error message will be returned: { \"error\" : \"Internal Error\" }","title":"Default exception handlers"},{"location":"user/exception/#customize-exception-handlers","text":"If one wants to intercept other exceptions and not use the default ones, one can create a function or a method inside a class and use the decorator handle_exception with the exception to capture. The following example captures the ValueError exceptions and return a response with the exception message. from pytcher import Request , handle_exception @handle_exception ( ValueError ) def handle_value_error ( request : Request , exception : ValueError ): return { \"error\" : str ( exception ) } And then pass it to the application App : from pytcher import App app = App ([ router , handle_value_error ]) app . run () Note that it can also be defined in the same class that defines the route: from pytcher import App , Request , route , handle_exception class MyRoute ( object ): @route ( path = '/items' ) def route ( self , r : Request ): return \"Hello\" @handle_exception ( ValueError ) def handle_value_error ( self , request : Request , exception : ValueError ): return { \"error\" : str ( exception ) } app = App ( MyRoute ()) app . run ()","title":"Customize exception handlers"},{"location":"user/install/","text":"Installation of pytcher This part of the documentation covers the installation of Pytcher. To install Pytcher, simply run this simple command in your terminal of choice: $ pip install pytcher Get the Source Code Pytcher is actively developed on GitHub at: https://github.com/chimpler/pytcher . You can either clone the public repository: $ git clone git://github.com/chimpler/pytcher.git Or, download the tarball . To install it: $ cd pytcher $ ./setup.py install .","title":"Install"},{"location":"user/install/#installation-of-pytcher","text":"This part of the documentation covers the installation of Pytcher. To install Pytcher, simply run this simple command in your terminal of choice: $ pip install pytcher","title":"Installation of pytcher"},{"location":"user/install/#get-the-source-code","text":"Pytcher is actively developed on GitHub at: https://github.com/chimpler/pytcher . You can either clone the public repository: $ git clone git://github.com/chimpler/pytcher.git Or, download the tarball . To install it: $ cd pytcher $ ./setup.py install .","title":"Get the Source Code"},{"location":"user/marshalling/","text":"Marshalling converts Python data (int, str, float, list, dict, data classes, named tuples) into a format that can be send across the wire. The user can request a particular format to be returned using the Accept request HTTP header: * application/json : accept JSON output * application/xml : accept XML output * text/csv : accept CSV output * */* : accept anything","title":"Marshalling"},{"location":"user/quickstart/","text":"Quickstart First, make sure that you have Pytcher installed and up to date: $ pip install pytcher --upgrade Create a simple web service Let's create a simple web service that returns Hello World! from pytcher import App , route class MyRoute ( object ): @route def route ( self , r ): return 'Hello World!' route = MyRoute () App ( route ) . start () You can run it as follows: $ python run_app.py On another window: $ curl localhost:8080 \"Hello World!\" Creating a more complex web service using a routing tree Let's create a more complex CRUD service with the endpoints: * /items * /items/<number> from pytcher import App , Router , Request , Integer , route class MyRouter ( Router ): def __init__ ( self ): self . _items = [ 'pizza' , 'cheese' , 'ice-cream' , 'butter' ] @route def route ( self , r : Request ): with r / 'items' : with r . end : with r . get : return self . _items with r . post : self . _items . append ( r . json ) return self . _items [ - 1 ] with r / Integer () as [ item_id ]: with r . get : return self . _items [ item_id ] with r . put : self . _items [ item_id ] = r . json return self . _items [ item_id ] with r . delete : return self . _items . pop ( item_id ) if __name__ == '__main__' : app = App ( MyRouter ()) app . start () Create a simple web service using dataclasses Create a simple web service using annotation For those more used to using decorators like in Flask, one can decorate multiple methods using a path and method. One can also use multiple classes to do so and combine with the routing tree structure.","title":"Quick start"},{"location":"user/quickstart/#quickstart","text":"First, make sure that you have Pytcher installed and up to date: $ pip install pytcher --upgrade","title":"Quickstart"},{"location":"user/quickstart/#create-a-simple-web-service","text":"Let's create a simple web service that returns Hello World! from pytcher import App , route class MyRoute ( object ): @route def route ( self , r ): return 'Hello World!' route = MyRoute () App ( route ) . start () You can run it as follows: $ python run_app.py On another window: $ curl localhost:8080 \"Hello World!\"","title":"Create a simple web service"},{"location":"user/quickstart/#creating-a-more-complex-web-service-using-a-routing-tree","text":"Let's create a more complex CRUD service with the endpoints: * /items * /items/<number> from pytcher import App , Router , Request , Integer , route class MyRouter ( Router ): def __init__ ( self ): self . _items = [ 'pizza' , 'cheese' , 'ice-cream' , 'butter' ] @route def route ( self , r : Request ): with r / 'items' : with r . end : with r . get : return self . _items with r . post : self . _items . append ( r . json ) return self . _items [ - 1 ] with r / Integer () as [ item_id ]: with r . get : return self . _items [ item_id ] with r . put : self . _items [ item_id ] = r . json return self . _items [ item_id ] with r . delete : return self . _items . pop ( item_id ) if __name__ == '__main__' : app = App ( MyRouter ()) app . start ()","title":"Creating a more complex web service using a routing tree"},{"location":"user/quickstart/#create-a-simple-web-service-using-dataclasses","text":"","title":"Create a simple web service using dataclasses"},{"location":"user/quickstart/#create-a-simple-web-service-using-annotation","text":"For those more used to using decorators like in Flask, one can decorate multiple methods using a path and method. One can also use multiple classes to do so and combine with the routing tree structure.","title":"Create a simple web service using annotation"},{"location":"user/route/","text":"","title":"Route"},{"location":"user/test/","text":"","title":"Test"},{"location":"user/unmarshalling/","text":"","title":"Unmarshalling"},{"location":"user/wsgi/","text":"Running pytcher using uWSGI Install uWSGI: $ pip install uwsgi To run it: $ uwsgi --http :8000 --wsgi-file examples/simple_app.py --pp examples -H venv3/ --wsgi simple_app:app","title":"WSGI"},{"location":"user/wsgi/#running-pytcher-using-uwsgi","text":"Install uWSGI: $ pip install uwsgi To run it: $ uwsgi --http :8000 --wsgi-file examples/simple_app.py --pp examples -H venv3/ --wsgi simple_app:app","title":"Running pytcher using uWSGI"}]}