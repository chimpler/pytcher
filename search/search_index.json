{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pytcher is a REST micro-framework for Python 3 that relies on a routing tree similar to RODA in Ruby, Akka HTTP in Scala or Javalin in Java. Danger Under development Features Marshalling / Unmarshalling of data classes (using types), namedtuples , date , datetime , uuid , ... Routing tree definition Additional Routing decorators similar to Flask Well scoped objects (no global variables) Support for WSGI","title":"Home"},{"location":"#features","text":"Marshalling / Unmarshalling of data classes (using types), namedtuples , date , datetime , uuid , ... Routing tree definition Additional Routing decorators similar to Flask Well scoped objects (no global variables) Support for WSGI","title":"Features"},{"location":"exception/","text":"Default exception handlers Exceptions can be intercepted and converted to a response with a status code. By default, if debug is enabled (by default), the exception will be captured and the server will response with error 500 with a detailed error description containing the error, the url, the headers and the stack trace: { \"error\" : \"list index out of range\" , \"url\" : \"/items/444\" , \"headers\" : { \"wsgi.input\" : \"<_io.BufferedReader name=7>\" , \"wsgi.errors\" : \"<_io.TextIOWrapper name='<stderr>' mode='w' encoding='UTF-8'>\" , \"wsgi.version\" : \"(1, 0)\" , \"wsgi.run_once\" : \"False\" , \"wsgi.multithread\" : \"True\" , \"wsgi.multiprocess\" : \"False\" , \"wsgi.file_wrapper\" : \"<class 'wsgiref.util.FileWrapper'>\" }, \"stack_trace\" : [ \"Traceback (most recent call last):\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 124, in _handle_request\" , \" None\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 117, in <genexpr>\" , \" output\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 120, in <genexpr>\" , \" for router in self._routers\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/__init__.py\\\", line 151, in run_router\" , \" return router.func(request, *matched_vars)\" , \" File \\\"examples/simple_app.py\\\", line 22, in route\" , \" return self._items[item_id]\" , \"IndexError: list index out of range\" , \"\" ] } If debug is disabled (for example in production), a simple Internal error message will be returned: { \"error\" : \"Internal Error\" } Customize exception handlers If one wants to intercept other exceptions and not use the default ones, one can create a function or a method inside a class and use the decorator handle_exception with the exception to capture. The following example captures the ValueError exceptions and return a response with the exception message. from pytcher import Request , handle_exception @handle_exception ( ValueError ) def handle_value_error ( request : Request , exception : ValueError ): return { \"error\" : str ( exception ) } And then pass it to the application App : from pytcher import App app = App ([ router , handle_value_error ]) app . run () Note that it can also be defined in the same class that defines the route: from pytcher import App , Request , route , handle_exception class MyRoute ( object ): @route ( path = '/items' ) def route ( self , r : Request ): return \"Hello\" @handle_exception ( ValueError ) def handle_value_error ( self , request : Request , exception : ValueError ): return { \"error\" : str ( exception ) } app = App ( MyRoute ()) app . run ()","title":"Exception"},{"location":"exception/#default-exception-handlers","text":"Exceptions can be intercepted and converted to a response with a status code. By default, if debug is enabled (by default), the exception will be captured and the server will response with error 500 with a detailed error description containing the error, the url, the headers and the stack trace: { \"error\" : \"list index out of range\" , \"url\" : \"/items/444\" , \"headers\" : { \"wsgi.input\" : \"<_io.BufferedReader name=7>\" , \"wsgi.errors\" : \"<_io.TextIOWrapper name='<stderr>' mode='w' encoding='UTF-8'>\" , \"wsgi.version\" : \"(1, 0)\" , \"wsgi.run_once\" : \"False\" , \"wsgi.multithread\" : \"True\" , \"wsgi.multiprocess\" : \"False\" , \"wsgi.file_wrapper\" : \"<class 'wsgiref.util.FileWrapper'>\" }, \"stack_trace\" : [ \"Traceback (most recent call last):\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 124, in _handle_request\" , \" None\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 117, in <genexpr>\" , \" output\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 120, in <genexpr>\" , \" for router in self._routers\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/__init__.py\\\", line 151, in run_router\" , \" return router.func(request, *matched_vars)\" , \" File \\\"examples/simple_app.py\\\", line 22, in route\" , \" return self._items[item_id]\" , \"IndexError: list index out of range\" , \"\" ] } If debug is disabled (for example in production), a simple Internal error message will be returned: { \"error\" : \"Internal Error\" }","title":"Default exception handlers"},{"location":"exception/#customize-exception-handlers","text":"If one wants to intercept other exceptions and not use the default ones, one can create a function or a method inside a class and use the decorator handle_exception with the exception to capture. The following example captures the ValueError exceptions and return a response with the exception message. from pytcher import Request , handle_exception @handle_exception ( ValueError ) def handle_value_error ( request : Request , exception : ValueError ): return { \"error\" : str ( exception ) } And then pass it to the application App : from pytcher import App app = App ([ router , handle_value_error ]) app . run () Note that it can also be defined in the same class that defines the route: from pytcher import App , Request , route , handle_exception class MyRoute ( object ): @route ( path = '/items' ) def route ( self , r : Request ): return \"Hello\" @handle_exception ( ValueError ) def handle_value_error ( self , request : Request , exception : ValueError ): return { \"error\" : str ( exception ) } app = App ( MyRoute ()) app . run ()","title":"Customize exception handlers"},{"location":"install/","text":"Installation of pytcher This part of the documentation covers the installation of Pytcher. To install Pytcher, simply run this simple command in your terminal of choice: $ pip install pytcher Get the Source Code Pytcher is actively developed on GitHub at: https://github.com/chimpler/pytcher . You can either clone the public repository: $ git clone git://github.com/chimpler/pytcher.git Or, download the tarball . To install it: $ cd pytcher $ ./setup.py install .","title":"Install"},{"location":"install/#installation-of-pytcher","text":"This part of the documentation covers the installation of Pytcher. To install Pytcher, simply run this simple command in your terminal of choice: $ pip install pytcher","title":"Installation of pytcher"},{"location":"install/#get-the-source-code","text":"Pytcher is actively developed on GitHub at: https://github.com/chimpler/pytcher . You can either clone the public repository: $ git clone git://github.com/chimpler/pytcher.git Or, download the tarball . To install it: $ cd pytcher $ ./setup.py install .","title":"Get the Source Code"},{"location":"marshalling/","text":"Marshalling converts Python data (int, str, float, list, dict, data classes, named tuples) into a format that can be send across the wire. The user can request a particular format to be returned using the Accept request HTTP header: application/json : accept JSON output application/xml : accept XML output text/csv : accept CSV output */* : accept anything Default supported types By default, pytcher accepts application/json and returns a JSON format output. Out of the box, it can marshall the followings: Type Description Example Output dict dictionary { 'key' : 'value' } { \"key\" : \"value } list list [ 'abc' , 'cde' ] [ \"abc\" , \"cde\" ] namedtuple named tuples Item ( 'apple' , 1.25 ) { \"name\" : \"apple\" , \"price\" : 1.25 } @dataclass data class Item ( 'apple' , 1.25 ) { \"name\" : \"apple\" , \"price\" : 1.25 } enum enum Color . RED \"RED\" str string 'apple' \"apple\" int integer 5 5 float float 5.12 5.12 date date datetime . date ( 2019 , 2 , 3 ) \"2019-02-03\" datetime datetime (no timezone) datetime . datetime ( 2019 , 2 , 3 , 12 , 32 , 1 ) \"2019-02-03T12:32:01.000\" datetime datetime (with timezone) datetime . datetime ( 2019 , 2 , 3 , 12 , 32 , 1 , tzinfo = pytz . UTC ) \"2019-02-03T12:32:01.000+00:00\" A namedtuple can be defined as follows: from collections import namedtuple Item = namedtuple ( 'Item' , [ 'name' , 'price' ]) apple = Item ( 'apple' , 1.25 ) A dataclass can be defined as follows: from dataclasses import dataclass @dataclass class Item ( object ): name : str price : float apple = Item ( 'apple' , 1.25 ) An enum can be defined as follows: from enum import Enum class Color ( Enum ): RED = 1 GREEN = 2 red = Color . RED Additional types One can also add additional types to support as follows: TODO Adding new accept formats","title":"Marshalling"},{"location":"marshalling/#default-supported-types","text":"By default, pytcher accepts application/json and returns a JSON format output. Out of the box, it can marshall the followings: Type Description Example Output dict dictionary { 'key' : 'value' } { \"key\" : \"value } list list [ 'abc' , 'cde' ] [ \"abc\" , \"cde\" ] namedtuple named tuples Item ( 'apple' , 1.25 ) { \"name\" : \"apple\" , \"price\" : 1.25 } @dataclass data class Item ( 'apple' , 1.25 ) { \"name\" : \"apple\" , \"price\" : 1.25 } enum enum Color . RED \"RED\" str string 'apple' \"apple\" int integer 5 5 float float 5.12 5.12 date date datetime . date ( 2019 , 2 , 3 ) \"2019-02-03\" datetime datetime (no timezone) datetime . datetime ( 2019 , 2 , 3 , 12 , 32 , 1 ) \"2019-02-03T12:32:01.000\" datetime datetime (with timezone) datetime . datetime ( 2019 , 2 , 3 , 12 , 32 , 1 , tzinfo = pytz . UTC ) \"2019-02-03T12:32:01.000+00:00\" A namedtuple can be defined as follows: from collections import namedtuple Item = namedtuple ( 'Item' , [ 'name' , 'price' ]) apple = Item ( 'apple' , 1.25 ) A dataclass can be defined as follows: from dataclasses import dataclass @dataclass class Item ( object ): name : str price : float apple = Item ( 'apple' , 1.25 ) An enum can be defined as follows: from enum import Enum class Color ( Enum ): RED = 1 GREEN = 2 red = Color . RED","title":"Default supported types"},{"location":"marshalling/#additional-types","text":"One can also add additional types to support as follows: TODO","title":"Additional types"},{"location":"marshalling/#adding-new-accept-formats","text":"","title":"Adding new accept formats"},{"location":"quickstart/","text":"Getting started First, make sure that you have Pytcher installed and up to date: $ pip install pytcher --upgrade Create a simple web service Let's create a simple web service that returns Hello World! from pytcher import App , Request , route class MyRoute ( object ): @route def route ( self , r : Request ): return 'Hello World!' route = MyRoute () App ( route ) . start () You can run it as follows: $ python run_app.py On another window: $ curl localhost:8080 \"Hello World!\" Creating a more complex web service using a routing tree Let's create a more complex CRUD service with the endpoints: /items GET : return the list of items POST : add an item /items/<number> PUT : replace the item at position <number> DELETE : delete the item at position <number> from pytcher import App , Router , Request , Integer , route class MyRouter ( Router ): def __init__ ( self ): self . _items = [ 'pizza' , 'cheese' , 'ice-cream' , 'butter' ] @route def route ( self , r : Request ): with r / 'items' : # if URL starts with /items with r . end : # if there is nothing after /items with r . get : # If it's a get request return self . _items with r . post : # If request is a post request self . _items . append ( r . json ) return self . _items [ - 1 ] with r / Integer () as item_id : # If the URL is /items/<integer> then bind item_id to the integer with r . get : # If the request is a get request return self . _items [ item_id ] with r . put : # If the request is a put request self . _items [ item_id ] = r . json return self . _items [ item_id ] with r . delete : # If the request is a delete request return self . _items . pop ( item_id ) if __name__ == '__main__' : app = App ( MyRouter ()) app . start () On another window, try the following commands: GET /items $ curl localhost:8000/items [\"pizza\",\"cheese\",\"ice-cream\",\"butter\"] GET /items/1 $ curl localhost:8000/items/1 \"cheese\" POST /items $ curl localhost:8000/items -XPOST -d \"ham\" \"ham\" $ curl localhost:8000/items [\"pizza\",\"cheese\",\"ice-cream\",\"butter\", \"ham\"] PUT /items/1 $ curl localhost:8000/items/1 -XPUT -d \"cucumber\" \"cucumber\" $ curl localhost:8000/items [\"pizza\",\"cucumber\",\"ice-cream\",\"butter\", \"ham\"] DELETE /items/1 $ curl localhost:8000/items/1 -XDELETE \"cucumber\" $ curl localhost:8000/items [\"pizza\",\"ice-cream\",\"butter\", \"ham\"] As you notice, we use the with statement context. In this case, if the request matches the condition (e.g., starts with /items or is GET request), then the code inside the block is executed. This can also be achieved using a for loop instead. For example: using with using for with r / 'items' : for _ in r / 'items' : with r . get / 'items' / Integer () as item_id : for item_id in r . get / 'items' / 'Integer' : Info The author of Python did not approve requests to use with statements to be conditional (i.e., execute the block if a certain condition occurs). We implemented it to make it work on cpython and possibly other implementations of Python. However using the for loop construction is perfectly fine and does not violate the Python standard. Create a simple web service using dataclasses In this example, we will take advantage of the data classes that were introduced in Python 3.7. from dataclasses import dataclass from pytcher import Integer , Request , route from pytcher.app import App @dataclass class InventoryItem ( object ): name : str unit_price : float quantity : int = 0 class MyRouter ( object ): def __init__ ( self ): words = [ 'wine' , 'pizza' , 'cheese' , 'peanuts' , 'ice-cream' ] self . _inventory = [ InventoryItem ( word , 10 + i , i + 1 ) for i in range ( 10 ) for word in words ] @route def route ( self , r : Request ): with r / 'items' : with r / Integer () as item_index : with r . get : return self . _inventory [ item_index ] with r . put : item = r . entity ( InventoryItem ) self . _inventory [ item_index ] = item return item with r . delete : item = self . _inventory [ item_index ] del self . _inventory [ item_index ] return item with r . end : with r . get : return self . _inventory with r . post : item = r . entity ( InventoryItem ) self . _inventory . append ( item ) return item if __name__ == '__main__' : app = App ( MyRouter ()) app . start () On another window, try the following commands: GET /items $ curl localhost:8000/items [ { \"name\": \"wine\", \"unit_price\": 10, \"quantity\": 1 }, { \"name\": \"pizza\", \"unit_price\": 10, \"quantity\": 1 }, { \"name\": \"cheese\", \"unit_price\": 10, \"quantity\": 1 }, [...] ] GET /items/1 $ curl localhost:8000/items/1 { \"name\": \"pizza\", \"unit_price\": 10, \"quantity\": 1 } POST /items $ curl localhost:8000/items -H \"Content-Type: application/json\" -XPOST -d '{ \"name\": \"pizza\", \"unit_price\": 10, \"quantity\": 1 }' { \"name\": \"pizza\", \"unit_price\": 10, \"quantity\": 1 } PUT /items/1 $ curl localhost:8000/items/1 -H \"Content-Type: application/json\" -XPUT -d '{ \"name\": \"corn\", \"unit_price\": 1, \"quantity\": 2 }' { \"name\": \"corn\", \"unit_price\": 1, \"quantity\": 2 } DELETE /items/1 $ curl localhost:8000/items/1 -XDELETE { \"name\": \"pizza\", \"unit_price\": 10, \"quantity\": 1 } Create a simple web service using annotation For those more used to using decorators like in Flask, one can decorate multiple methods using a path and method. import logging from dataclasses import dataclass from pytcher import Request , route from pytcher.app import App logger = logging . getLogger ( __name__ ) @dataclass class InventoryItem ( object ): name : str unit_price : float quantity : int = 0 class MyRouter ( object ): def __init__ ( self ): words = [ 'wine' , 'pizza' , 'cheese' , 'peanuts' , 'ice-cream' ] self . _inventory = [ InventoryItem ( word , 10 + i , i + 1 ) for i in range ( 10 ) for word in words ] @route ( path = '/items/<int:id>' , method = 'GET' ) def get_item ( self , r : Request , id ): return self . _inventory [ id ] @route ( path = '/items' , method = 'GET' ) def list_items ( self , request ): return self . _inventory @route ( path = '/items' , method = 'POST' ) def route ( self , r : Request ): with r . post : item = r . entity ( InventoryItem ) self . _inventory . append ( item ) return item if __name__ == '__main__' : logging . basicConfig ( level = logging . DEBUG ) logging . debug ( 'This will get logged' ) app = App ( MyRouter (), debug = True ) app . start () Combining @route and routing tree In this example, we combine the use of the @route decorator using the prefix /items with a routing tree. This can be a common pattern, especially when using multiple router classes (e.g., one class with /admin and another one to handle items ). import logging from dataclasses import dataclass from pytcher import Request , route , Integer from pytcher.app import App logger = logging . getLogger ( __name__ ) @dataclass class InventoryItem ( object ): name : str unit_price : float quantity : int = 0 class MyRouter ( object ): def __init__ ( self ): words = [ 'wine' , 'pizza' , 'cheese' , 'peanuts' , 'ice-cream' ] self . _inventory = [ InventoryItem ( word , 10 + i , i + 1 ) for i in range ( 10 ) for word in words ] @route ( prefix = '/items' ) def handle_items ( self , r : Request ): with r / Integer as item_index : with r . get : return self . _inventory [ item_index ] with r . put : item = r . entity ( InventoryItem ) self . _inventory [ item_index ] = item return item with r . delete : item = self . _inventory [ item_index ] del self . _inventory [ item_index ] return item with r . end : with r . get : return self . _inventory with r . post : item = r . entity ( InventoryItem ) self . _inventory . append ( item ) return item if __name__ == '__main__' : logging . basicConfig ( level = logging . DEBUG ) logging . debug ( 'This will get logged' ) app = App ( MyRouter (), debug = True ) print () print ( 'Try: curl localhost:8000/items' ) print ( 'Try: curl localhost:8000/items/2' ) print () app . start () All the examples can be found in the examples folder . More features To use multiple routers, one can simply pass them to App . For example: app = App ([ AdminRouter (), ItemRouter ()]) app . run ()","title":"Getting Started"},{"location":"quickstart/#getting-started","text":"First, make sure that you have Pytcher installed and up to date: $ pip install pytcher --upgrade","title":"Getting started"},{"location":"quickstart/#create-a-simple-web-service","text":"Let's create a simple web service that returns Hello World! from pytcher import App , Request , route class MyRoute ( object ): @route def route ( self , r : Request ): return 'Hello World!' route = MyRoute () App ( route ) . start () You can run it as follows: $ python run_app.py On another window: $ curl localhost:8080 \"Hello World!\"","title":"Create a simple web service"},{"location":"quickstart/#creating-a-more-complex-web-service-using-a-routing-tree","text":"Let's create a more complex CRUD service with the endpoints: /items GET : return the list of items POST : add an item /items/<number> PUT : replace the item at position <number> DELETE : delete the item at position <number> from pytcher import App , Router , Request , Integer , route class MyRouter ( Router ): def __init__ ( self ): self . _items = [ 'pizza' , 'cheese' , 'ice-cream' , 'butter' ] @route def route ( self , r : Request ): with r / 'items' : # if URL starts with /items with r . end : # if there is nothing after /items with r . get : # If it's a get request return self . _items with r . post : # If request is a post request self . _items . append ( r . json ) return self . _items [ - 1 ] with r / Integer () as item_id : # If the URL is /items/<integer> then bind item_id to the integer with r . get : # If the request is a get request return self . _items [ item_id ] with r . put : # If the request is a put request self . _items [ item_id ] = r . json return self . _items [ item_id ] with r . delete : # If the request is a delete request return self . _items . pop ( item_id ) if __name__ == '__main__' : app = App ( MyRouter ()) app . start () On another window, try the following commands: GET /items $ curl localhost:8000/items [\"pizza\",\"cheese\",\"ice-cream\",\"butter\"] GET /items/1 $ curl localhost:8000/items/1 \"cheese\" POST /items $ curl localhost:8000/items -XPOST -d \"ham\" \"ham\" $ curl localhost:8000/items [\"pizza\",\"cheese\",\"ice-cream\",\"butter\", \"ham\"] PUT /items/1 $ curl localhost:8000/items/1 -XPUT -d \"cucumber\" \"cucumber\" $ curl localhost:8000/items [\"pizza\",\"cucumber\",\"ice-cream\",\"butter\", \"ham\"] DELETE /items/1 $ curl localhost:8000/items/1 -XDELETE \"cucumber\" $ curl localhost:8000/items [\"pizza\",\"ice-cream\",\"butter\", \"ham\"] As you notice, we use the with statement context. In this case, if the request matches the condition (e.g., starts with /items or is GET request), then the code inside the block is executed. This can also be achieved using a for loop instead. For example: using with using for with r / 'items' : for _ in r / 'items' : with r . get / 'items' / Integer () as item_id : for item_id in r . get / 'items' / 'Integer' : Info The author of Python did not approve requests to use with statements to be conditional (i.e., execute the block if a certain condition occurs). We implemented it to make it work on cpython and possibly other implementations of Python. However using the for loop construction is perfectly fine and does not violate the Python standard.","title":"Creating a more complex web service using a routing tree"},{"location":"quickstart/#create-a-simple-web-service-using-dataclasses","text":"In this example, we will take advantage of the data classes that were introduced in Python 3.7. from dataclasses import dataclass from pytcher import Integer , Request , route from pytcher.app import App @dataclass class InventoryItem ( object ): name : str unit_price : float quantity : int = 0 class MyRouter ( object ): def __init__ ( self ): words = [ 'wine' , 'pizza' , 'cheese' , 'peanuts' , 'ice-cream' ] self . _inventory = [ InventoryItem ( word , 10 + i , i + 1 ) for i in range ( 10 ) for word in words ] @route def route ( self , r : Request ): with r / 'items' : with r / Integer () as item_index : with r . get : return self . _inventory [ item_index ] with r . put : item = r . entity ( InventoryItem ) self . _inventory [ item_index ] = item return item with r . delete : item = self . _inventory [ item_index ] del self . _inventory [ item_index ] return item with r . end : with r . get : return self . _inventory with r . post : item = r . entity ( InventoryItem ) self . _inventory . append ( item ) return item if __name__ == '__main__' : app = App ( MyRouter ()) app . start () On another window, try the following commands: GET /items $ curl localhost:8000/items [ { \"name\": \"wine\", \"unit_price\": 10, \"quantity\": 1 }, { \"name\": \"pizza\", \"unit_price\": 10, \"quantity\": 1 }, { \"name\": \"cheese\", \"unit_price\": 10, \"quantity\": 1 }, [...] ] GET /items/1 $ curl localhost:8000/items/1 { \"name\": \"pizza\", \"unit_price\": 10, \"quantity\": 1 } POST /items $ curl localhost:8000/items -H \"Content-Type: application/json\" -XPOST -d '{ \"name\": \"pizza\", \"unit_price\": 10, \"quantity\": 1 }' { \"name\": \"pizza\", \"unit_price\": 10, \"quantity\": 1 } PUT /items/1 $ curl localhost:8000/items/1 -H \"Content-Type: application/json\" -XPUT -d '{ \"name\": \"corn\", \"unit_price\": 1, \"quantity\": 2 }' { \"name\": \"corn\", \"unit_price\": 1, \"quantity\": 2 } DELETE /items/1 $ curl localhost:8000/items/1 -XDELETE { \"name\": \"pizza\", \"unit_price\": 10, \"quantity\": 1 }","title":"Create a simple web service using dataclasses"},{"location":"quickstart/#create-a-simple-web-service-using-annotation","text":"For those more used to using decorators like in Flask, one can decorate multiple methods using a path and method. import logging from dataclasses import dataclass from pytcher import Request , route from pytcher.app import App logger = logging . getLogger ( __name__ ) @dataclass class InventoryItem ( object ): name : str unit_price : float quantity : int = 0 class MyRouter ( object ): def __init__ ( self ): words = [ 'wine' , 'pizza' , 'cheese' , 'peanuts' , 'ice-cream' ] self . _inventory = [ InventoryItem ( word , 10 + i , i + 1 ) for i in range ( 10 ) for word in words ] @route ( path = '/items/<int:id>' , method = 'GET' ) def get_item ( self , r : Request , id ): return self . _inventory [ id ] @route ( path = '/items' , method = 'GET' ) def list_items ( self , request ): return self . _inventory @route ( path = '/items' , method = 'POST' ) def route ( self , r : Request ): with r . post : item = r . entity ( InventoryItem ) self . _inventory . append ( item ) return item if __name__ == '__main__' : logging . basicConfig ( level = logging . DEBUG ) logging . debug ( 'This will get logged' ) app = App ( MyRouter (), debug = True ) app . start ()","title":"Create a simple web service using annotation"},{"location":"quickstart/#combining-route-and-routing-tree","text":"In this example, we combine the use of the @route decorator using the prefix /items with a routing tree. This can be a common pattern, especially when using multiple router classes (e.g., one class with /admin and another one to handle items ). import logging from dataclasses import dataclass from pytcher import Request , route , Integer from pytcher.app import App logger = logging . getLogger ( __name__ ) @dataclass class InventoryItem ( object ): name : str unit_price : float quantity : int = 0 class MyRouter ( object ): def __init__ ( self ): words = [ 'wine' , 'pizza' , 'cheese' , 'peanuts' , 'ice-cream' ] self . _inventory = [ InventoryItem ( word , 10 + i , i + 1 ) for i in range ( 10 ) for word in words ] @route ( prefix = '/items' ) def handle_items ( self , r : Request ): with r / Integer as item_index : with r . get : return self . _inventory [ item_index ] with r . put : item = r . entity ( InventoryItem ) self . _inventory [ item_index ] = item return item with r . delete : item = self . _inventory [ item_index ] del self . _inventory [ item_index ] return item with r . end : with r . get : return self . _inventory with r . post : item = r . entity ( InventoryItem ) self . _inventory . append ( item ) return item if __name__ == '__main__' : logging . basicConfig ( level = logging . DEBUG ) logging . debug ( 'This will get logged' ) app = App ( MyRouter (), debug = True ) print () print ( 'Try: curl localhost:8000/items' ) print ( 'Try: curl localhost:8000/items/2' ) print () app . start () All the examples can be found in the examples folder .","title":"Combining @route and routing tree"},{"location":"quickstart/#more-features","text":"To use multiple routers, one can simply pass them to App . For example: app = App ([ AdminRouter (), ItemRouter ()]) app . run ()","title":"More features"},{"location":"route/","text":"Routes can be defined using different ways: using the decorator @route within a function/method decorated using @route and using the with statement within a function/method decorated using @route and using the for statement @route decorator One can use the @route decorator on a function or a class method which has as parameter a request object. For instance: from pytcher import App , Request , route @route def route ( request : Request ): return 'Hello world' app = App ([ route ]) app . run () Also, like Flask, one can also pass the expected HTTP method (default to GET ) and the path (that can contain binding variables) that defaults to / . In this case, the parameters of the function/method will be: request object binding variables For instance: from pytcher import App , Request , route @route ( path = '/items/<int:item_id>' , method = 'GET' ) def route ( request : Request , item_id : int ): return { 'item' : item_id } Routing tree Inside a function or a method decorated with @route The routing tree can be defined using with statements or for loops. The following example using with statements: from pytcher import route , Request , Integer @route def route ( r : Request ): with r / 'v1' : with r . get / 'items' / Integer as item_id : return { 'Item' : item_id } Can be rewritten with for loops as follows: from pytcher import route , Request , Integer @route def route ( r : Request ): for _ in r / 'v1' : for item_id in r . get / 'items' / Integer : return { 'Item' : item_id } Let's consider an example with 2 bindings. In this case, the binding will return a list instead of a single value. For example, the URL path /books/2/pages/3 will match the route r / 'books' / Integer / 'pages' / Integer and binds the 2 int to a list of 2 elements: with r / 'books' / Integer / 'pages' / Integer as [ book_id , page ]: return { 'book_id' : book_id , 'page' : page } or using a for loop construction: for book_id , page in r / 'books' / Integer / 'pages' / Integer : return { 'book_id' : book_id , 'page' : page } Method matcher The HTTP methods can be matched as follows: Method route GET with r . get : PUT with r . put : POST with r . post : DELETE with r . delete : PATCH with r . patch : HEAD with r . head : Path matcher Paths can be defined using path elements separated by / . For example with r / 'v2' / 'items:' will match the path /v2/items . One can also use the following matchers: Matcher Description Example Integer ( min = None , max = None ) Match an Integer between min and max with r / 'books' / Integer () / 'pages' / Integer () as [ book_id , page ]: Float ( min = None , max = None ) Match a float between min and max with r / 'values' / Float () as [ price ]: Date ( format = 'YYYY-MM-DD' ) Match a date with r / 'data' / Date () as [ date ]: Choice ( value1 , value2 , ... , ignore_case = True ]) Match different strings with r / Choice ([ 'books' , 'novels]) as [book_type]: str Match a string with r / 'data' : Regex ( regex , flags , data_types ) Match a regex with r / 'data' / Regex ( '(.*)-(.*)' ) as [[ a , b ]]: None Match the end of the path with r / 'items' / None : request . end match the end of the path with r . end : Info If you use default parameters, you can use the matcher class or the instance. For example Integer or Integer() Integer matcher Integer ( min : int = None , max : int = None ) : Matches if the path element is an integer. Optionally you can provide the boundaries (inclusive). Float matcher Float ( min : float = None , max : float = None ) : Matches if the path element is a float. Optionally you can provide the boundaries (inclusive). Date matcher Date ( format = '%Y-%m- %d ' ) : Matches if the path element is a date. By default the format is %Y-%m-%d (e.g., 2019-03-02 ). For the format see the Python datetime page . Choice matcher Choice ( choice1 : str , choice2 : str , ... , ignore_case : bool = True ) : Matches if the path element is one of strings provided. By default it is case insensitive but one can set ignore_case to False to be case sensitive. str matcher str : Simply use a string for exact match, for example r / 'items' will match if the path element matches items None : Indicate the end of the request URL. For example r / 'items' / None indicates that the URL ended at items end : Indicate the end of the request URL. For example r.end indicates that the URL ended Regex matcher If no matching group is provided to the Regex matcher, it will return the whole string that matches. If a single capturing group is provided, it will return the string that matches the group If multiple capturing groups are provided, it will return an array of strings that matches the groups. It can also take care of type conversion by providing data_types which is an array of types the groups are supposed to be. For example: with r / Regex ( '^fruit-(?P<name>.*)-(?P<size>\\d+)$' , data_types = [ str , int ]) as [ name , size ]: return { 'fruit' : name , 'size' : size } will bind the first group as a str and size as an int . The URL /fruit-orange-15 will result in the following result: { \"fruit\" : \"orange\" , \"size\" : 15 } None matcher Example using path matchers Here is an example of routing tree: from pytcher import route , Request @route def route ( r : Request ): with r / 'books' : # If path starts with '/books' with r . end : # If path matches exactly `/books` return { \"message\" : \"something\" } with r / 'info' / None : # If path matches exactly `/books/info`: return { \"info\" : \"nothing\" } with r / String () / 'page' / Integer () / None as [ book_id , page ]: # For example /books/test/page/10 return { \"book\" : book_id , \"page\" : page } Parameter matcher Conditions can be put on parameter values (for example http://localhost/items?token=45ab ). This can be done as follows: from pytcher import route , Request @route def route ( r : Request ): with r . p [ 'token' ] == '45ab' : return { 'message' : 'Hello!' } return { 'message' : \"Bye!\" } It can also use operators such as > or < for numeric values. Below is the full list of supported operators: Operator Description Example == equal r . p [ 'token' ] == 'secret-token' != not equal r . p [ 'type' ] != 'fruit' > greater than r . p [ 'price' ] > 100 < less than r . p [ 'price' ] < 100 >= greater or equal r . p [ 'price' ] >= 100 <= less or equal r . p [ 'price' ] <= 100 in contains 'apple' in r . p [ 'fruits' ] Header matcher Info HTTP Headers are not case-sensitive (so X-Organization will be treated the same as x-organization ) Similarly to parameter matchers, conditions can be put on header values. For example one can check if X-Organization is set to my-company . This can be done as follows: from pytcher import route , Request @route def route ( r : Request ): with r . h [ 'X-Organization' ] == 'my-company' : return { 'message' : 'Hello my-company employee!' } return { 'message' : \"Go away!\" } It can also use operators such as > or < for numeric values. Below is the full list of supported operators: Operator Description Example == equal r . h [ 'Token' ] == 'secret-token' != not equal r . h [ 'X-Organization' ] != 'my-company' > greater than r . h [ 'money' ] > 100 < less than r . h [ 'money' ] < 100 >= greater or equal r . h [ 'money' ] >= 100 <= less or equal r . h [ 'money' ] <= 100 in contains 'apple' in r . h [ 'fruits' ] Combining matchers One can use boolean expressions with & (and) and | (or). For example: from pytcher import route , Request @route def route ( r : Request ): with ( r / 'items' ) & r . h [ 'X-Organization' ] == 'my-company' : return { \"items\" : [ { \"name\" : \"pear\" }, { \"name\" : \"apple\" } ] }","title":"Route"},{"location":"route/#route-decorator","text":"One can use the @route decorator on a function or a class method which has as parameter a request object. For instance: from pytcher import App , Request , route @route def route ( request : Request ): return 'Hello world' app = App ([ route ]) app . run () Also, like Flask, one can also pass the expected HTTP method (default to GET ) and the path (that can contain binding variables) that defaults to / . In this case, the parameters of the function/method will be: request object binding variables For instance: from pytcher import App , Request , route @route ( path = '/items/<int:item_id>' , method = 'GET' ) def route ( request : Request , item_id : int ): return { 'item' : item_id }","title":"@route decorator"},{"location":"route/#routing-tree","text":"Inside a function or a method decorated with @route The routing tree can be defined using with statements or for loops. The following example using with statements: from pytcher import route , Request , Integer @route def route ( r : Request ): with r / 'v1' : with r . get / 'items' / Integer as item_id : return { 'Item' : item_id } Can be rewritten with for loops as follows: from pytcher import route , Request , Integer @route def route ( r : Request ): for _ in r / 'v1' : for item_id in r . get / 'items' / Integer : return { 'Item' : item_id } Let's consider an example with 2 bindings. In this case, the binding will return a list instead of a single value. For example, the URL path /books/2/pages/3 will match the route r / 'books' / Integer / 'pages' / Integer and binds the 2 int to a list of 2 elements: with r / 'books' / Integer / 'pages' / Integer as [ book_id , page ]: return { 'book_id' : book_id , 'page' : page } or using a for loop construction: for book_id , page in r / 'books' / Integer / 'pages' / Integer : return { 'book_id' : book_id , 'page' : page }","title":"Routing tree"},{"location":"route/#method-matcher","text":"The HTTP methods can be matched as follows: Method route GET with r . get : PUT with r . put : POST with r . post : DELETE with r . delete : PATCH with r . patch : HEAD with r . head :","title":"Method matcher"},{"location":"route/#path-matcher","text":"Paths can be defined using path elements separated by / . For example with r / 'v2' / 'items:' will match the path /v2/items . One can also use the following matchers: Matcher Description Example Integer ( min = None , max = None ) Match an Integer between min and max with r / 'books' / Integer () / 'pages' / Integer () as [ book_id , page ]: Float ( min = None , max = None ) Match a float between min and max with r / 'values' / Float () as [ price ]: Date ( format = 'YYYY-MM-DD' ) Match a date with r / 'data' / Date () as [ date ]: Choice ( value1 , value2 , ... , ignore_case = True ]) Match different strings with r / Choice ([ 'books' , 'novels]) as [book_type]: str Match a string with r / 'data' : Regex ( regex , flags , data_types ) Match a regex with r / 'data' / Regex ( '(.*)-(.*)' ) as [[ a , b ]]: None Match the end of the path with r / 'items' / None : request . end match the end of the path with r . end : Info If you use default parameters, you can use the matcher class or the instance. For example Integer or Integer()","title":"Path matcher"},{"location":"route/#integer-matcher","text":"Integer ( min : int = None , max : int = None ) : Matches if the path element is an integer. Optionally you can provide the boundaries (inclusive).","title":"Integer matcher"},{"location":"route/#float-matcher","text":"Float ( min : float = None , max : float = None ) : Matches if the path element is a float. Optionally you can provide the boundaries (inclusive).","title":"Float matcher"},{"location":"route/#date-matcher","text":"Date ( format = '%Y-%m- %d ' ) : Matches if the path element is a date. By default the format is %Y-%m-%d (e.g., 2019-03-02 ). For the format see the Python datetime page .","title":"Date matcher"},{"location":"route/#choice-matcher","text":"Choice ( choice1 : str , choice2 : str , ... , ignore_case : bool = True ) : Matches if the path element is one of strings provided. By default it is case insensitive but one can set ignore_case to False to be case sensitive.","title":"Choice matcher"},{"location":"route/#str-matcher","text":"str : Simply use a string for exact match, for example r / 'items' will match if the path element matches items None : Indicate the end of the request URL. For example r / 'items' / None indicates that the URL ended at items end : Indicate the end of the request URL. For example r.end indicates that the URL ended","title":"str matcher"},{"location":"route/#regex-matcher","text":"If no matching group is provided to the Regex matcher, it will return the whole string that matches. If a single capturing group is provided, it will return the string that matches the group If multiple capturing groups are provided, it will return an array of strings that matches the groups. It can also take care of type conversion by providing data_types which is an array of types the groups are supposed to be. For example: with r / Regex ( '^fruit-(?P<name>.*)-(?P<size>\\d+)$' , data_types = [ str , int ]) as [ name , size ]: return { 'fruit' : name , 'size' : size } will bind the first group as a str and size as an int . The URL /fruit-orange-15 will result in the following result: { \"fruit\" : \"orange\" , \"size\" : 15 }","title":"Regex matcher"},{"location":"route/#none-matcher","text":"","title":"None matcher"},{"location":"route/#example-using-path-matchers","text":"Here is an example of routing tree: from pytcher import route , Request @route def route ( r : Request ): with r / 'books' : # If path starts with '/books' with r . end : # If path matches exactly `/books` return { \"message\" : \"something\" } with r / 'info' / None : # If path matches exactly `/books/info`: return { \"info\" : \"nothing\" } with r / String () / 'page' / Integer () / None as [ book_id , page ]: # For example /books/test/page/10 return { \"book\" : book_id , \"page\" : page }","title":"Example using path matchers"},{"location":"route/#parameter-matcher","text":"Conditions can be put on parameter values (for example http://localhost/items?token=45ab ). This can be done as follows: from pytcher import route , Request @route def route ( r : Request ): with r . p [ 'token' ] == '45ab' : return { 'message' : 'Hello!' } return { 'message' : \"Bye!\" } It can also use operators such as > or < for numeric values. Below is the full list of supported operators: Operator Description Example == equal r . p [ 'token' ] == 'secret-token' != not equal r . p [ 'type' ] != 'fruit' > greater than r . p [ 'price' ] > 100 < less than r . p [ 'price' ] < 100 >= greater or equal r . p [ 'price' ] >= 100 <= less or equal r . p [ 'price' ] <= 100 in contains 'apple' in r . p [ 'fruits' ]","title":"Parameter matcher"},{"location":"route/#header-matcher","text":"Info HTTP Headers are not case-sensitive (so X-Organization will be treated the same as x-organization ) Similarly to parameter matchers, conditions can be put on header values. For example one can check if X-Organization is set to my-company . This can be done as follows: from pytcher import route , Request @route def route ( r : Request ): with r . h [ 'X-Organization' ] == 'my-company' : return { 'message' : 'Hello my-company employee!' } return { 'message' : \"Go away!\" } It can also use operators such as > or < for numeric values. Below is the full list of supported operators: Operator Description Example == equal r . h [ 'Token' ] == 'secret-token' != not equal r . h [ 'X-Organization' ] != 'my-company' > greater than r . h [ 'money' ] > 100 < less than r . h [ 'money' ] < 100 >= greater or equal r . h [ 'money' ] >= 100 <= less or equal r . h [ 'money' ] <= 100 in contains 'apple' in r . h [ 'fruits' ]","title":"Header matcher"},{"location":"route/#combining-matchers","text":"One can use boolean expressions with & (and) and | (or). For example: from pytcher import route , Request @route def route ( r : Request ): with ( r / 'items' ) & r . h [ 'X-Organization' ] == 'my-company' : return { \"items\" : [ { \"name\" : \"pear\" }, { \"name\" : \"apple\" } ] }","title":"Combining matchers"},{"location":"test/","text":"","title":"Test"},{"location":"unmarshalling/","text":"It is common to read payload (in JSON) sent from the client using the POST or PUT method. In most cases, the POST request will send the JSON representation of a Python object that will then need to be unmarshalled to an object. This can be achieved using the entity method of the Request object passed to the function decorated with @route . Supported types: Type Description Example int integer 3 float float 3.4 str string \"test\" boolean boolean \"true\" None NULL value NULL datetime datetime \"2019-02-01T02:03:04\" datetime with timezone datetime with timezone \"2019-02-01T02:03:04-04:00\" timezone timezone \"America/New_York\" date date \"2019-04-02\" time time \"14:03:12\" data class dataclass dictionary representing the data class list list [ 1 , 2 , 3 ] dict dictionary { \"key\" : \"value\" } namedtuple named tuple dictionary representing the named tuple Info To parse datetime , date and time we rely on the library dateutil and for parsing timezone , we use the library pytz . Example We consider Item to be a data class defined as follows: from dataclasses import dataclass @dataclass class Item ( object ): name : str price : float apple = Item ( 'apple' , 1.25 ) Example Description r . entity ( List [ Float ]) Create a list of float r . entity ( MyDataClassObject ) Create the data class object Item r . entity ( List [ Item ]) Create a list of data classes Item r . entity ( Dict [ Str , Item ]) Create a dictionary of Str -> Item Optionally, one can specify a JSON path . For example if the Item is wrapped in a \"data\" element: { \"data\" : { \"name\" : \"pear\" , \"price\" : 1.45 } } Item can be obtained using the json path $.data as follows: r . entity ( Item , '$.data' )","title":"Unmarshalling"},{"location":"unmarshalling/#example","text":"We consider Item to be a data class defined as follows: from dataclasses import dataclass @dataclass class Item ( object ): name : str price : float apple = Item ( 'apple' , 1.25 ) Example Description r . entity ( List [ Float ]) Create a list of float r . entity ( MyDataClassObject ) Create the data class object Item r . entity ( List [ Item ]) Create a list of data classes Item r . entity ( Dict [ Str , Item ]) Create a dictionary of Str -> Item Optionally, one can specify a JSON path . For example if the Item is wrapped in a \"data\" element: { \"data\" : { \"name\" : \"pear\" , \"price\" : 1.45 } } Item can be obtained using the json path $.data as follows: r . entity ( Item , '$.data' )","title":"Example"},{"location":"wsgi/","text":"Running pytcher using uWSGI Pytcher can be run as a WSGI application. In this page, we will describe how to use uWSGI . Install uWSGI: $ pip install uwsgi If you use a virtualenv venv3 , you can run the example simple_app.py as follows: $ uwsgi --http :8000 --wsgi-file examples/simple_app.py --pp examples -H venv3/ --wsgi simple_app:app uWSGI configuration Minimal configuration [uwsgi] module = simple_app callable = app master = true processes = 5 socket = uwsgi.sock Docker deployment","title":"WSGI"},{"location":"wsgi/#running-pytcher-using-uwsgi","text":"Pytcher can be run as a WSGI application. In this page, we will describe how to use uWSGI . Install uWSGI: $ pip install uwsgi If you use a virtualenv venv3 , you can run the example simple_app.py as follows: $ uwsgi --http :8000 --wsgi-file examples/simple_app.py --pp examples -H venv3/ --wsgi simple_app:app","title":"Running pytcher using uWSGI"},{"location":"wsgi/#uwsgi-configuration","text":"Minimal configuration [uwsgi] module = simple_app callable = app master = true processes = 5 socket = uwsgi.sock","title":"uWSGI configuration"},{"location":"wsgi/#docker-deployment","text":"","title":"Docker deployment"}]}