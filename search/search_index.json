{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Pytcher Pytcher is a REST micro-framework for Python that relies on a routing tree similar to RODA in Ruby, Akka HTTP in Scala or Javalin in Java. Danger Under development Features Marshalling / Unmarshalling of data classes (using types), namedtuples , date , datetime , uuid , ... Routing tree definition Routing decorator similar to Flask Well scoped objects (no global variables) Support for WSGI Simple example from pytcher import App , Router , Request , Integer class MyRouter ( object ): def __init__ ( self ): self . version = 'v1' self . _items = [ 'pizza' , 'cheese' , 'ice-cream' , 'butter' ] @route def route ( self , r : Request ): with r / self . version / 'items' : with r . end : with r . get : return self . _items with r . post : self . _items . append ( r . json ) return self . _items [ - 1 ] with r / Integer () as [ item_id ]: with r . get : return self . _items [ item_id ] with r . put : self . _items [ item_id ] = r . json return self . _items [ item_id ] with r . delete : return self . _items . pop ( item_id ) if __name__ == '__main__' : app = App ( MyRouter ()) app . start ()","title":"Home"},{"location":"#welcome-to-pytcher","text":"Pytcher is a REST micro-framework for Python that relies on a routing tree similar to RODA in Ruby, Akka HTTP in Scala or Javalin in Java. Danger Under development","title":"Welcome to Pytcher"},{"location":"#features","text":"Marshalling / Unmarshalling of data classes (using types), namedtuples , date , datetime , uuid , ... Routing tree definition Routing decorator similar to Flask Well scoped objects (no global variables) Support for WSGI","title":"Features"},{"location":"#simple-example","text":"from pytcher import App , Router , Request , Integer class MyRouter ( object ): def __init__ ( self ): self . version = 'v1' self . _items = [ 'pizza' , 'cheese' , 'ice-cream' , 'butter' ] @route def route ( self , r : Request ): with r / self . version / 'items' : with r . end : with r . get : return self . _items with r . post : self . _items . append ( r . json ) return self . _items [ - 1 ] with r / Integer () as [ item_id ]: with r . get : return self . _items [ item_id ] with r . put : self . _items [ item_id ] = r . json return self . _items [ item_id ] with r . delete : return self . _items . pop ( item_id ) if __name__ == '__main__' : app = App ( MyRouter ()) app . start ()","title":"Simple example"},{"location":"user/example/","text":"","title":"Examples"},{"location":"user/exception/","text":"Default exception handlers Exceptions can be intercepted and converted to a response with a status code. By default, if debug is enabled (by default), the exception will be captured and the server will response with error 500 with a detailed error description containing the error, the url, the headers and the stack trace: { \"error\" : \"list index out of range\" , \"url\" : \"/items/444\" , \"headers\" : { \"wsgi.input\" : \"<_io.BufferedReader name=7>\" , \"wsgi.errors\" : \"<_io.TextIOWrapper name='<stderr>' mode='w' encoding='UTF-8'>\" , \"wsgi.version\" : \"(1, 0)\" , \"wsgi.run_once\" : \"False\" , \"wsgi.multithread\" : \"True\" , \"wsgi.multiprocess\" : \"False\" , \"wsgi.file_wrapper\" : \"<class 'wsgiref.util.FileWrapper'>\" }, \"stack_trace\" : [ \"Traceback (most recent call last):\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 124, in _handle_request\" , \" None\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 117, in <genexpr>\" , \" output\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 120, in <genexpr>\" , \" for router in self._routers\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/__init__.py\\\", line 151, in run_router\" , \" return router.func(request, *matched_vars)\" , \" File \\\"examples/simple_app.py\\\", line 22, in route\" , \" return self._items[item_id]\" , \"IndexError: list index out of range\" , \"\" ] } If debug is disabled (for example in production), a simple Internal error message will be returned: { \"error\" : \"Internal Error\" } Customize exception handlers If one wants to intercept other exceptions and not use the default ones, one can create a function or a method inside a class and use the decorator handle_exception with the exception to capture. The following example captures the ValueError exceptions and return a response with the exception message. from pytcher import Request , handle_exception @handle_exception ( ValueError ) def handle_value_error ( request : Request , exception : ValueError ): return { \"error\" : str ( exception ) } And then pass it to the application App : from pytcher import App app = App ([ router , handle_value_error ]) app . run () Note that it can also be defined in the same class that defines the route: from pytcher import App , Request , route , handle_exception class MyRoute ( object ): @route ( path = '/items' ) def route ( self , r : Request ): return \"Hello\" @handle_exception ( ValueError ) def handle_value_error ( self , request : Request , exception : ValueError ): return { \"error\" : str ( exception ) } app = App ( MyRoute ()) app . run ()","title":"Exception"},{"location":"user/exception/#default-exception-handlers","text":"Exceptions can be intercepted and converted to a response with a status code. By default, if debug is enabled (by default), the exception will be captured and the server will response with error 500 with a detailed error description containing the error, the url, the headers and the stack trace: { \"error\" : \"list index out of range\" , \"url\" : \"/items/444\" , \"headers\" : { \"wsgi.input\" : \"<_io.BufferedReader name=7>\" , \"wsgi.errors\" : \"<_io.TextIOWrapper name='<stderr>' mode='w' encoding='UTF-8'>\" , \"wsgi.version\" : \"(1, 0)\" , \"wsgi.run_once\" : \"False\" , \"wsgi.multithread\" : \"True\" , \"wsgi.multiprocess\" : \"False\" , \"wsgi.file_wrapper\" : \"<class 'wsgiref.util.FileWrapper'>\" }, \"stack_trace\" : [ \"Traceback (most recent call last):\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 124, in _handle_request\" , \" None\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 117, in <genexpr>\" , \" output\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/app.py\\\", line 120, in <genexpr>\" , \" for router in self._routers\" , \" File \\\"/Users/fdang/chimpler/pytcher/pytcher/__init__.py\\\", line 151, in run_router\" , \" return router.func(request, *matched_vars)\" , \" File \\\"examples/simple_app.py\\\", line 22, in route\" , \" return self._items[item_id]\" , \"IndexError: list index out of range\" , \"\" ] } If debug is disabled (for example in production), a simple Internal error message will be returned: { \"error\" : \"Internal Error\" }","title":"Default exception handlers"},{"location":"user/exception/#customize-exception-handlers","text":"If one wants to intercept other exceptions and not use the default ones, one can create a function or a method inside a class and use the decorator handle_exception with the exception to capture. The following example captures the ValueError exceptions and return a response with the exception message. from pytcher import Request , handle_exception @handle_exception ( ValueError ) def handle_value_error ( request : Request , exception : ValueError ): return { \"error\" : str ( exception ) } And then pass it to the application App : from pytcher import App app = App ([ router , handle_value_error ]) app . run () Note that it can also be defined in the same class that defines the route: from pytcher import App , Request , route , handle_exception class MyRoute ( object ): @route ( path = '/items' ) def route ( self , r : Request ): return \"Hello\" @handle_exception ( ValueError ) def handle_value_error ( self , request : Request , exception : ValueError ): return { \"error\" : str ( exception ) } app = App ( MyRoute ()) app . run ()","title":"Customize exception handlers"},{"location":"user/install/","text":"Installation of pytcher This part of the documentation covers the installation of Pytcher. To install Pytcher, simply run this simple command in your terminal of choice: $ pip install pytcher Get the Source Code Pytcher is actively developed on GitHub at: https://github.com/chimpler/pytcher . You can either clone the public repository: $ git clone git://github.com/chimpler/pytcher.git Or, download the tarball . To install it: $ cd pytcher $ ./setup.py install .","title":"Install"},{"location":"user/install/#installation-of-pytcher","text":"This part of the documentation covers the installation of Pytcher. To install Pytcher, simply run this simple command in your terminal of choice: $ pip install pytcher","title":"Installation of pytcher"},{"location":"user/install/#get-the-source-code","text":"Pytcher is actively developed on GitHub at: https://github.com/chimpler/pytcher . You can either clone the public repository: $ git clone git://github.com/chimpler/pytcher.git Or, download the tarball . To install it: $ cd pytcher $ ./setup.py install .","title":"Get the Source Code"},{"location":"user/marshalling/","text":"Marshalling converts Python data (int, str, float, list, dict, data classes, named tuples) into a format that can be send across the wire. The user can request a particular format to be returned using the Accept request HTTP header: application/json : accept JSON output application/xml : accept XML output text/csv : accept CSV output */* : accept anything Default supported types By default, pytcher accepts application/json and returns a JSON format output. Out of the box, it can marshall the followings: Type Description Example Output dict dictionary {'key': 'value'} {\"key\":\"value} list list ['abc', 'cde'] [\"abc\",\"cde\"] namedtuple named tuples Item('apple', 1.25) {\"name\":\"apple\",\"price\":1.25} @dataclass data class Item('apple', 1.25) {\"name\":\"apple\",\"price\":1.25} enum enum Color.RED \"RED\" str string 'apple' \"apple\" int integer 5 5 float float 5.12 5.12 date date datetime.date(2019, 2, 3) 2019-02-03 datetime datetime (no timezone) datetime.datetime(2019, 2, 3, 12, 32, 1) 2019-02-03T12:32:01.000 datetime datetime (with timezone) datetime.datetime(2019, 2, 3, 12, 32, 1, tzinfo=pytz.UTC) 2019-02-03T12:32:01.000+00:00 A namedtuple can be defined as follows: from collections import namedtuple Item = namedtuple ( 'Item' , [ 'name' , 'price' ]) apple = Item ( 'apple' , 1.25 ) A dataclass can be defined as follows: from dataclasses import dataclass @dataclass class Item ( object ): name : str price : float apple = Item ( 'apple' , 1.25 ) An enum can be defined as follows: from enum import Enum class Color ( Enum ): RED = 1 GREEN = 2 red = Color . RED Additional types One can also add additional types to support as follows: TODO Adding new accept formats","title":"Marshalling"},{"location":"user/marshalling/#default-supported-types","text":"By default, pytcher accepts application/json and returns a JSON format output. Out of the box, it can marshall the followings: Type Description Example Output dict dictionary {'key': 'value'} {\"key\":\"value} list list ['abc', 'cde'] [\"abc\",\"cde\"] namedtuple named tuples Item('apple', 1.25) {\"name\":\"apple\",\"price\":1.25} @dataclass data class Item('apple', 1.25) {\"name\":\"apple\",\"price\":1.25} enum enum Color.RED \"RED\" str string 'apple' \"apple\" int integer 5 5 float float 5.12 5.12 date date datetime.date(2019, 2, 3) 2019-02-03 datetime datetime (no timezone) datetime.datetime(2019, 2, 3, 12, 32, 1) 2019-02-03T12:32:01.000 datetime datetime (with timezone) datetime.datetime(2019, 2, 3, 12, 32, 1, tzinfo=pytz.UTC) 2019-02-03T12:32:01.000+00:00 A namedtuple can be defined as follows: from collections import namedtuple Item = namedtuple ( 'Item' , [ 'name' , 'price' ]) apple = Item ( 'apple' , 1.25 ) A dataclass can be defined as follows: from dataclasses import dataclass @dataclass class Item ( object ): name : str price : float apple = Item ( 'apple' , 1.25 ) An enum can be defined as follows: from enum import Enum class Color ( Enum ): RED = 1 GREEN = 2 red = Color . RED","title":"Default supported types"},{"location":"user/marshalling/#additional-types","text":"One can also add additional types to support as follows: TODO","title":"Additional types"},{"location":"user/marshalling/#adding-new-accept-formats","text":"","title":"Adding new accept formats"},{"location":"user/quickstart/","text":"Quickstart First, make sure that you have Pytcher installed and up to date: $ pip install pytcher --upgrade Create a simple web service Let's create a simple web service that returns Hello World! from pytcher import App , route class MyRoute ( object ): @route def route ( self , r ): return 'Hello World!' route = MyRoute () App ( route ) . start () You can run it as follows: $ python run_app.py On another window: $ curl localhost:8080 \"Hello World!\" Creating a more complex web service using a routing tree Let's create a more complex CRUD service with the endpoints: * /items * /items/<number> from pytcher import App , Router , Request , Integer , route class MyRouter ( Router ): def __init__ ( self ): self . _items = [ 'pizza' , 'cheese' , 'ice-cream' , 'butter' ] @route def route ( self , r : Request ): with r / 'items' : # if URL starts with /items with r . end : # if there is nothing after /items with r . get : # If it's a get request return self . _items with r . post : # If request is a post request self . _items . append ( r . json ) return self . _items [ - 1 ] with r / Integer () as [ item_id ]: # If the URL is /items/<integer> then bind item_id to the integer with r . get : # If the request is a get request return self . _items [ item_id ] with r . put : # If the request is a put request self . _items [ item_id ] = r . json return self . _items [ item_id ] with r . delete : # If the request is a delete request return self . _items . pop ( item_id ) if __name__ == '__main__' : app = App ( MyRouter ()) app . start () As you notice, we use the with statement context. In this case, if the request matches the condition (e.g., starts with /items or is GET request), then the code inside the block is executed. This can also be achieved using a for loop instead. For example: using with using for with r / 'items': for _ in r / 'items': with r.get / 'items' / Integer() as [item_id]: for item_id in r.get / 'items' / 'Integer': Create a simple web service using dataclasses Create a simple web service using annotation For those more used to using decorators like in Flask, one can decorate multiple methods using a path and method. One can also use multiple classes to do so and combine with the routing tree structure.","title":"Quick start"},{"location":"user/quickstart/#quickstart","text":"First, make sure that you have Pytcher installed and up to date: $ pip install pytcher --upgrade","title":"Quickstart"},{"location":"user/quickstart/#create-a-simple-web-service","text":"Let's create a simple web service that returns Hello World! from pytcher import App , route class MyRoute ( object ): @route def route ( self , r ): return 'Hello World!' route = MyRoute () App ( route ) . start () You can run it as follows: $ python run_app.py On another window: $ curl localhost:8080 \"Hello World!\"","title":"Create a simple web service"},{"location":"user/quickstart/#creating-a-more-complex-web-service-using-a-routing-tree","text":"Let's create a more complex CRUD service with the endpoints: * /items * /items/<number> from pytcher import App , Router , Request , Integer , route class MyRouter ( Router ): def __init__ ( self ): self . _items = [ 'pizza' , 'cheese' , 'ice-cream' , 'butter' ] @route def route ( self , r : Request ): with r / 'items' : # if URL starts with /items with r . end : # if there is nothing after /items with r . get : # If it's a get request return self . _items with r . post : # If request is a post request self . _items . append ( r . json ) return self . _items [ - 1 ] with r / Integer () as [ item_id ]: # If the URL is /items/<integer> then bind item_id to the integer with r . get : # If the request is a get request return self . _items [ item_id ] with r . put : # If the request is a put request self . _items [ item_id ] = r . json return self . _items [ item_id ] with r . delete : # If the request is a delete request return self . _items . pop ( item_id ) if __name__ == '__main__' : app = App ( MyRouter ()) app . start () As you notice, we use the with statement context. In this case, if the request matches the condition (e.g., starts with /items or is GET request), then the code inside the block is executed. This can also be achieved using a for loop instead. For example: using with using for with r / 'items': for _ in r / 'items': with r.get / 'items' / Integer() as [item_id]: for item_id in r.get / 'items' / 'Integer':","title":"Creating a more complex web service using a routing tree"},{"location":"user/quickstart/#create-a-simple-web-service-using-dataclasses","text":"","title":"Create a simple web service using dataclasses"},{"location":"user/quickstart/#create-a-simple-web-service-using-annotation","text":"For those more used to using decorators like in Flask, one can decorate multiple methods using a path and method. One can also use multiple classes to do so and combine with the routing tree structure.","title":"Create a simple web service using annotation"},{"location":"user/route/","text":"Routes can be defined using different ways: using the decorator @route within a function/method decorated using @route and using the with statement within a function/method decorated using @route and using the for statement","title":"Route"},{"location":"user/test/","text":"","title":"Test"},{"location":"user/unmarshalling/","text":"It is common to read payload (in JSON) sent from the client using the POST or PUT method. In most cases, the POST request will send the JSON representation of a Python object that will then need to be unmarshalled to an object. This can be achieved using the entity method of the Request object passed to the function decorated with @route . For example: We consider Item to be a data class defined as follows: from dataclasses import dataclass @dataclass class Item ( object ): name : str price : float apple = Item ( 'apple' , 1.25 ) Example Description r.entity(List[Float]) Create a list of float r.entity(MyDataClassObject) Create the data class object Item r.entity(List[Item]) Create a list of data classes Item r.entity(Dict[Str, Item]) Create a dictionary of Str -> Item Optionally, one can specify a JSON path . For example if the Item is wrapped in a \"data\" element: { \"data\" : { \"name\" : \"pear\" , \"price\" : 1.45 } } Item can be obtained using the json path $.data as follows: r . entity ( Item , '$.data' )","title":"Unmarshalling"},{"location":"user/wsgi/","text":"Running pytcher using uWSGI Pytcher can be run as a WSGI application. In this page, we will describe how to use uWSGI . Install uWSGI: $ pip install uwsgi To run it: $ uwsgi --http :8000 --wsgi-file examples/simple_app.py --pp examples -H venv3/ --wsgi simple_app:app","title":"WSGI"},{"location":"user/wsgi/#running-pytcher-using-uwsgi","text":"Pytcher can be run as a WSGI application. In this page, we will describe how to use uWSGI . Install uWSGI: $ pip install uwsgi To run it: $ uwsgi --http :8000 --wsgi-file examples/simple_app.py --pp examples -H venv3/ --wsgi simple_app:app","title":"Running pytcher using uWSGI"}]}